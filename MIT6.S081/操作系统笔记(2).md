# 操作系统笔记



考核重点：**进程管理**、**内存管理**

难点：**内存管理**

期中考试之前学习的难点：**同步**

# 1操作系统导论

## 1.1 操作系统是什么

### 定义

1. 始终运行在计算机上的程序，要么是应用程序，要么是系统程序
2. 在应用程序和计算机硬件的中介。执行用户程序，有效使用计算机硬件

## 1.2 计算机系统组织

系统后台程序(system daemon)，在启动时加载到内存，它启动许多其它系统的后台程序。

事件发生通过硬件或软件的中断来通知。

## 1.4 操作系统结构

多道(multiprogramming)：非剥夺性的，主动让出CPU

分时多任务(time sharing multitasking):剥夺性的，响应时间很短，一般不超过1s. 切换频率很高，用户可以与操作系统交互。



进程(process):加载到内存并执行的程序，称为进程。

作业调度，CPU调度

操作系统需要合理的响应时间，通过交换(swapping)来实现

## 1.5 操作系统的执行

### 中断驱动

分为硬件中断和**软件中断**(softwear interrupt)(如陷阱trap或者用户请求user request)

用户请求，比如系统调用。用户通过系统调用访问硬件，用户调用一系列系统封装好的函数，这是为了安全性。

软中断一般不是立即处理的。

### 1.5.1双重模式和多重模式的执行

双重模式：

用户模式和内核模式（又称为系统模式或特权模式）

处于内核模式下，用户可以通过系统调用对硬件进行操作

在用户进程中，通过**软中断**的方法来执行系统调用代码，这样做是为了**安全性**

## 1.5.2定时器

为了防止用户程序陷入死循环或者既不系统调用又不释放CPU使用权，这个时候通过定时器和硬中断来跳脱循环。

这里可以解决多道方式下进程调度出现的问题。

## 1.6进程管理

进程像演出，程序像剧本。

程序计数器指定程序下一个需要执行的指令。

执行的任务：

1. 在CPU上调度的进程和线程
2. 创建和删除用户进程和系统进程
3. **挂起**(**suspending**)和重启进程
4. 提供进程**同步**(**synchronization**)机制
5. 提供进程通信机制
6. 提供死锁处理机制

死锁是由同步产生的.

## 1.7内存管理

CPU需要执行的指令存放在内存中.

任务:

1. 记录没存的那部分在被使用以及被谁使用
2. 决定那些进程调入调出内存
3. 根据需要分配和释放内存空间

## 1.8存储管理

操作系统对存储设备的物理属性进行了抽象,并定义了逻辑存储单元,即**文件(file)**

文件是相关信息的集合，产生一个中介作用

文件可以组织成目录(文件的文件)。

文件还可以隐藏起来，不让用户看到。

需要控制用户访问文件方式(读、写、执行)

### 1.8.1 文件管理活动

1. **创建和删除**文件和目录
2. **提供**文件和目录的操作原语
3. **映射**文件到外存
4. **备份**文件到稳定(非易失的)存储介质

### 1.8.2 大容量存储管理



### 1.8.3 高速缓存

内存是磁盘的缓存，磁盘是磁带机的缓存

目的是弥补CPU与外设之间巨大的速度差，使得效率提升

当不同场景多任务的时候，应该尽量确保**高速缓存一致性**，这通常是硬件问题(在操作系统底下处理)

处理这种数据时，操作系统应该尽快更新其副本，或许可以加锁来使该数据暂时不共享，从而使得并行性变为串行性的，保证安全性

### 1.8.4 I/O系统

在UNIX系统中，I/O子系统为操作系统隐藏了IO特性

1. 包括缓冲、告诉缓存和**假脱机技术**的内存管理组件

   这种假脱机技术**提高了I/O速度**、**设备并没有分配给任何输入/输出进程**、**实现了虚拟设备功能**

   假脱机是以磁盘为中介的缓存，弥补了速度差。

## 1.9 保护与安全

操作系统必须要有的功能(保护性)：

1. 软中断。当系统超出空间是，要进行中断，使系统陷入一个trap
2. 定时器。当陷入死循环时，系统需要设置定时器打破这个循环

保护可以提高可靠性(reliability)

安全性是方位各种各样的攻击，保护病毒感染。

## 1.10 分布式系统

一个操作系统管理很多机器

好处为：

1. 资源共享
2. 计算速度加快-加载共享、加载平衡
3. 可靠性
4. 可用性

## 1.11 特殊目的操作系统

### 1.11.1 实时操作系统

实时操作系统具有明确的、固定的时间约束。

分时操作系统只需要响应快。

批处理系统没有任何时间约束。

## 1.12 计算环境

### 客户端-服务器计算

缺点是更新客户端较为麻烦



现代PC采用B/S架构，通过浏览器提供服务。

## 对等(peer-to-peer)计算

# 2 操作系统结构

## 2.1 操作系统服务

1. 用户界面(UI)：一般有多种形式，包括**命令行界面**(Command-line interface,CLI),和**图形用户界面**(Graph User Interface,GUI)，还有一种是**批处理界面**(batch interface).
2. 程序执行：加载程序到内存，执行程序，停止执行(正常或异常).
3. I/O操作：访问文件或IO设备，操作系统需要提供方法让进程通过服务顺利安全地访问文件或IO设备。
4. 文件系统操作：读写，创建删除，搜索，列出文件信息，授权。
5. 通信：实现**共享内存**(shared memory)，**消息传递**(message passing),由于共享内存不安全，需要进行同步和互斥操作。消息传递是把数据打包，效率很低但是很安全。
6. 错误检测(Error detection):检测和更正错误。错误来源有：CPU或硬件、IO设备、用户程序等

操作系统还提供其他服务

1. 资源分配(resource allocation):CPU需要设置资源调度算法，可以根据优先级来设置。但是如果有的设备等待时间过长，需要有一个补偿机制，使得优先级不断提升。
2. 记账(accounting):记录用户使用的资源类型和数量。
3. 保护与安全(protection and security):保护是控制所有进程的资源权限。安全是保护外部I/O设备不受非法访问。

## 2.2 用户与操作系统的界面

### 2.2.1 命令行解释器

解释程序称为外壳(shell)

命令行解释器有两种命令。

一是CLI就可以解释执行命令(常见操作)的，另一种是复杂命令，将文件加载到内存，通过操作系统执行命令。

### 2.2.2 图形用户界面





## 2.3 系统调用(system call)

系统调用提供操作系统服务接口，使用API接口。调用常以C或C++编写。对于某些底层任务(直接访问硬件的任务)或者内核调用、中断处理等，常用汇编语言编写。

### API

API中的函数，使得每个函数都有输入参数和返回值。

应用程序员针对API函数进行编程，以希望程序能够在任何支持同一API的系统上编译和执行，这样体现了程序的可移植性。

#### API好处

即为什么使用API而不是系统调用

1. 便携性：
2. 简易性：

### 参数传递

三种方法：

1. 寄存器传递参数
2. 地址(block，又名指针)传递：将地址通过寄存器传递，通过地址访问数据
3. 堆栈(stack)传递：把堆栈地址和数据长度传递给API函数，当需要的时候，一个一个地往外pop

## 2.4 系统调用类型

系统调用分为六大类：

1. 进程控制(process control)
2. 文件管理(file manipulation)
3. 设备管理(device manipulation)
4. 信息维护(information maintenance)
5. 通信(communication)
6. 保护(protection)

### 2.4.1 进程控制

![image-20240304153155357](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240304153155357.png)

fork命令：创建子进程，该子进程是对父进程全部地复制，包括现在程序指针指向地位置。

#### MS-DOS

单任务系统，只有一个程序指针。进程完成后，指针又指向解释器。

#### FreeBSD

通过fork()和exit()来完成多个进程的调用。

## 2.5 系统程序

操作系统由**系统调用和系统程序**组成。系统程序以上的APP不属于操作系统的范畴，而是属于**用户**范畴。

包含很多功能



对于大多数用户来说，更多的是接触系统程序和APP，接触不到系统内核。

## 2.6 OS的设计与实现

### 2.6.1 设计目标

用户目标和系统目标

### 2.6.2 机制与策略

不应该硬编码，不能把机制写死在操作系统中

机制决定如何做，策略决定做什么。

策略与机制必须分离，这是一种原则。

对于策略改变不敏感的通用机制是可行的。

#### 例子

微内核的OS，就是机制与策略分离。

#### 反例

windows，就没有分离，但是做的很好。

### 2.6.3 实现

用C/C++来编写实现程序，内核最底层的代码用汇编语言来写。

因为C/C++易读懂

高级语言**缺点：**速度的降低和存储的增加。

操作系统的性能提升更多来源于更好的**数据结构和算法**

## 2.7 操作系统的结构

### 2.7.2 分层方法



### 2.7.3 微内核

微内核核心是将保证基本功能，把大部分功能交给代码

优点：

便于扩展

安全可靠

缺点：

增大系统调用开销

两个程序之间的通信需要借助内核进行，增大内核使用，内核成为瓶颈。

### 2.7.4 模块化

使用面向对象的方法调用内核

内核有一组核心组件，和动态链接额外的服务。

内核变成了一个开放的结构，根据实际运行状态对内核进行重组。

## 2.8 虚拟机

好处：

1. 可以用一台机器实现三台机器的功能，比如：两台机器的通讯，可以用原系统和虚拟机的操作系统进行通信
2. 安全性高，比如：网上的软件不知道有没有木马。一旦中毒，只是虚拟机中毒了，将虚拟机文件删除就一点事都没有。
3. 虚拟机可以使得一台机器有两个操作系统。

缺点：

1. 由于有两层操作系统和一层虚拟机的调用，效率损失较大。

### Java virtual machine

是一种语言解释器

为了能让java执行，虚拟了一个环境。

是一个大型的API图书馆

## 2.9 操作系统的生成

把所用东西放在注册表当中，任何修改都修改注册表，

## 2.10 系统引导(booting)

大多数计算机都有一小段代码，称为引导加载程序。

该段程序放在ROM中，代码能够定位内核，并将其加载到内存中开始执行。

首先完成自检，然后寻找内核，把内核写入内存，然后把本机控制权交给操作系统，让操作系统成为真正的主人。

# 第三章 进程

## 3.1 进程的概念

批处理系统执行**作业**，分时系统使用**用户程序**或**任务**。

操作系统也需要程序如文件管理 

所有的这些活动称为**进程**。

### 3.1.1 进程

虽然两个进程可以与一个程序联系起来，但是这两个进程是两个**独立的进程流**。

### 3.1.2 进程状态

五态模型

**![image-20240311152913159](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240311152913159.png)**

### 3.1.3 进程控制块

经典的进程只有一个指令流。一个指令流称为一个线程。

![image-20240315141151080](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240315141151080.png)

### 3.1.4 线程

传统模型中，一个进程只能有一个线程。现在的模型一个进程可以有多个线程。

多线程好处：

可以通过数组变量同步运行，而不需要用消息和共享内存的方式。

## 3.2 进程调度

多道程序设计的目标是：无论何时都有进程运行，从而使得CPU使用率最大化。

分时系统的目的是：在进程之间快速切换CPU，从而实现用户在程序运行时交互。

进程调度器从ready状态的进程中选择一个可用进程到CPU上执行。

### 3.2.1 调度队列

作业队列：进程在进入系统时，会被加入作业队列，包括计算机中的所有进程。



就绪队列：驻留在内存中的、就绪的、等待运行的进程保存在就绪队列。



设备队列：等待特定I/O设备的进程列表，称为设备队列。每个设备都有自己的设备队列。

### 3.2.2 调度程序

长期调度程序从缓冲池中选择进程执行。

短期调度程序从就绪的进程中选择进程执行。

短期调度程序必须快速，否则就会使得调度所占时间过大，过于浪费。

长期调度程序将I/O密集型进程和CPU密集型进程合理安排组合，让进程进入就绪队列。

中程调度程序(或swapping)：释放一个进程所占资源，降低多道程度。之后进程可重新调入内存，并从中断处执行。

### 3.2.3 上下文切换

切换CPU到另一个进程需要保存当前进程状态和恢复另一个进程的状态，这个任务称为上下文切换。

上下文切换的时间是纯粹的开销。

## 3.3 进程运行

### 3.3.1 进程创建

当一个进程创建子进程时，该子进程需要一定的资源(CPU时间、内存、文件、I/O设备等)。

子进程可以从操作系统中直接获取资源，或者从父进程哪里获取资源，即父进程及子进程分配资源或资源共享。限制子进程只能使用父进程的资源，可以防止创建过多进程，导致系统超载。

在**fork()**以后

1. 父进程可能与子进程执行同步，也就是父进程**没有wait()**。
2. 子进程调用**exec()**函数，子进程相当于改行了(与父进程没有联系)，但是共用了父进程的资源。

### 3.3.2 进程终止

分为两种情况。

1. 进程正常执行结束，调用**exit()**，让系统删除自己
2. 父进程通过**abort()**函数使得子进程终止，此时通常是因为子进程占用太多资源或者做的事情没必要。所有子进程的终止都是级联终止，也就是说，父进程消亡前夕，必须让子进程先于父进程消亡。如果子进程没结束而父进程结束，那么子进程就变成了游离的进程，操作系统就无法掌控该进城了。

## 3.4 进程内通信

操作系统进程可以是独立的或是协作的。

**独立的**：不影响其他进程或不被其他进程影响，不与其他任何进程共享数据资源。

**协作的**：相互影响，共享数据。

协作的**好处**：

1. 信息共享
2. 计算加速
3. 模块化
4. 方便

协作进程需要**进程内通信(interprocess communication, IPC)**机制来完成。

**两种IPC模型**

1. 共享内存：创建共享内存初期，需要通过系统调用来完成，需要操作系统的允许。因为任何进程创建初期，只能访问自己所属内存空间，除非得到操作系统的允许。
2. 信息传递：交换小数量的数据是有用的。比共享内存易于实现。慢于共享内存，但是安全

### 3.4.1 共享内存系统

生产者与消费者问题。

### 3.4.2 消息传递系统

两种操作

1. send：发送的消息可以是**定长**的也可以是**变长**的。

   定长的系统级实现简单，但编程任务困难。变长的系统级实现复杂，但编程任务简单。

2. receive：

#### 3.4.2.1 命名

1.直接通信(direct communication):分为**对称的**、**非对称的**。

对称的：把对方的名字都写在原型函数当中，即一个链路只与两个进程相连，一个逻辑链路只链接两个进程。

非对称的：发送必须指定接收者，而接收者可以接收所有人的消息。

缺点：用到了**硬编码技术**，需要把进程ID写入函数，需要不停改程序。

2.间接通信(indirect communication):用到了邮箱(mailbox or ports)机制，发送方先把消息发到邮箱公共区域，接收者通过邮箱把消息取走。

规定，在某一个时刻只能有一个接收者，或者系统任意指定一个接收者。避免多个接收者同时接收产生错误。

#### 3.4.2.2 同步

信息传递可以是**阻塞(blocking)**或**非阻塞(nonblocking)**，也成为**同步(synchronous)**或**异步(asynchronous)**。

其中有消费者和生产者的协同。

一般方式为：非阻塞发送，阻塞接收的方式。

如果是无限大缓冲，那么发送者需要非阻塞，以便发送者能够发送足量信息，或者生产者慢而消费者快时，也可以认为缓冲区无限大。

# 第四章 线程

## 4.1 概述

![image-20240322141644029](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240322141644029.png)

一个传统进程只有一个线程。如果一个进程具有多个控制线程，那么它能同时执行多个任务。

### 4.1.1 动机

多线程例子：web浏览器、字处理机、数据库服务器、web服务器。

### 4.1.2 优点

1. 响应性：部分阻塞或者执行冗长操作，不影响执行其他指令，从而增加对用户的相应程度。
2. 资源共享：代码和数据共享，允许一个应用程序在同一地址空间内有多个不同活动线程。
3. 经济：对于Solaris，进程创建比线程(**同属于一个进程**)慢30倍，进程切换比线程(**同属于一个进程**)慢5倍。
4. 可伸缩性：对于多处理器体系结构，多线程可以在多处理核上并行运行

## 4.2 多核线程

用户线程：运行在用户态的线程，执行用户代码。用户线程不参加CPU的调度。

内核线程：

### 多对一

用户线程有很多个，但只能有一个能与内核线程通信。所有的用户线程由用户进程进行管理。

**优点：**

用户线程由用户进程管理，所以管理线程很高效(不需要经常调用系统调用)。

**缺点：**

1. 如果一个线程参与CPU调度，但是线程阻塞了，整个进程都进入阻塞状态。
2. 由于同一时间只能有一个线程访问内核，那么多线程不能平行运行在多处理机上。

### 一对一

每个用户线程对应一个内核线程。不需要内部进行竞争。线程与内核态可以自由切换。

### 多对多

允许多个用户线程与多个内核线程相对应。例如：规定内核线程有400个，多个用户线程最多同时与这400个内核线程对应，否则进入阻塞状态。

![image-20240322145856984](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240322145856984.png)

![image-20240322145910350](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240322145910350.png)

**双层模型**：对于重要的线程，可以直接参与内核调度。

## 4.3 线程库

为程序员提供创建和管理线程的API。

主要实现方法：

1. 在用户空间中提供一个没有内核支持的库。所有代码和数据结构都位于用户空间。调用库函数导致本地函数的调用
2. 实现由操作系统直接支持的内核级的库。代码和数据结构都位于内核空间。调用库函数导致对内核的系统调用。

三种线程库：

POSIX Pthreads、Windows、Java。

## 4.4 线程问题

### The fork() and exec() system calls

一个进程中的十个线程中的其中一个线程调用fork()，这个system call 是对整个进程的复制。由此提出两个版本的system call。

1. 如果对父进程进行全面复制(复制所有线程)，其中一个线程调用fork()，而不调用exec()。
2. 如果仅仅想复制其中一个进程，那么该线程调用fork()之后，紧接着调用exec()。

### 线程取消

终止一个未运行完毕的线程。

两种方式：

1. 立即终止
2. 推迟终止

### 信号处理

由特殊事件发出来的信号，遵循一下模式：

信号由特殊事件产生，一个通用信号被传递给进程，一旦传递，必须被处理。

这称为软中断。

主要作用：处理不定期发生的，不是很重要的事件。

**信号量**

同步或者异步。

同步信号是发送给自己的，比如：进程访问内存越界，产生错误，触发一个产生错误的信号。或者除零了。

异步信号是发送给其他进程的，比如：分时系统的时钟服务进程，时间到了，产生中断发送给其他进程。或者特定按键终止进程。

处理信号时：

1. 由进程处理信号函数处理
2. 将该信号广播给进程中的全部线程
3. 由进程中的一个线程处理
4. 指定一个特定接收所有信号的线程，并由该线程处理。

### 线程池

主要思想：在进程开始时创建一定数量的线程，并加到池中以等待工作。当服务器收到请求时，它会唤醒池内的一个线程，并将需要服务的请求传递给它。一旦线程完成了服务，它会返回到池中再等待工作。如果池内没有可用线程，那么服务器会等待，直到有空线程为止。

优点：

1. 启动快
2. 线程池限制了可用线程数量，这对那些不能支持大量并发线程的系统非常重要。(即规定了上限)。
3. 将要执行任务从创建任务机制中分离出来，允许采用不同策略运行任务。

### 调度程序激活

用户线程库和内核之间的一种通信方案称为调度器激活(scheduler activation)。当线程阻塞时，内核讲有关特定事件通知应用程序，这个步骤称为**回调(upcall)**，由线程库通过**回调处理程序(upcall handler)**来处理。此时内核分配一个新的虚拟处理器给应用程序。

## 4.5操作系统举例

### Linux线程

linux通过clone()创建线程。clone()允许子线程**共享**父线程的地址空间。

# 第五章 CPU调度

CPU调度是多道程序操作系统的基础。进程间切换CPU，使得计算机更加高效。

## 5.1 基本概念

**CPU执行分布**

I/O密集型程序具有大量短CPU执行。CPU执行由大量短CPU执行和少量长CPU执行组成。这种分布对于选择合适的CPU调度算法很重要。

80%的CPU执行应该小于分时系统的时间片。

### 5.1.2 CPU调度程序

每当CPU空闲时，操作系统应从就绪队列中选择一个进程来执行。进程选择采用**短期调度程序(short-term scheduler)**。

### 5.1.3 抢占调度

当需要进行CPU调度时，分为以下四种情况：

1. 当一个进程从运行状态切换到等待状态(如：I/O请求，或wait()调用)
2. 当一个进程从运行状态切换到就绪状态时(如，出现中断)
3. 当一个进程从等待状态切换到就绪状态时(如，I/O完成)，为了给某些**高优先级**的进程**特权**。
4. 当一个进程终止时。

### 5.1.4 调度程序

调度程序(dispatcher)，是一个模块，用来将CPU控制交给短期调度程序选择的进程。功能包括：

1. 切换上下文
2. 切换到用户模式
3. 跳转到用户程序的合适位置，以便重新启动程序。

调度程序停止一个进程而启动另一个进程所需的时间称为**调度延迟(dispatch latency)**。

## 5.2 调度准则

包括：

1. **CPU使用率**：应该使CPU尽可能地忙碌。
2. **吞吐量：**指在一个时间单元内进程完成的数量。
3. **周转时间：**从进程提交到进程完成的时间段称为周转时间(turnaround time)。
4. **等待时间**：等待时间为在就绪队列中等待所花的时间之和。
5. **响应时间：**从提交请求到产生第一响应的时间。对于分时系统来说，**时间片越短，响应时间越短**。

对于交互式系统(如时间共享系统)。需要：最小化响应时间的波动性比最小化平均响应时间更重要。

## 5.3 调度算法(重点):happy:

### 5.3.1 先到先服务调度($$FCFS$$)

first-come first-served, $$FCFS$$调度算法：

1. 先请求CPU的进程首先分配到$$CPU$$。
2. 算法易于通过FIFO队列实现。

缺点：平均等待时间往往很长。整个系统的波动性过分依赖于外界任务到达的顺序。

由于，$$FCFS$$调度算法是非抢占性的，一旦$$CPU$$分配给了一个进程，就会使用$$CPU$$直到释放。允许一个进程使用$$CPU$$过长将是个严重的错误。

### 5.3.2 最短作业优先调度($$SJF$$)

这个算法将每个进程与其下次CPU执行的长度关联起来。

可以证明$$SJF$$调度算法是最优的。这是因为通过将短进程移到长进程之前，短进程的等待时间减少大于长进程的等待时间增加。因而，平均等待时间减少。

新来的任务时间和正在运行的任务的剩余时间综合比较。

$$SJF$$算法可以既是剥夺的，也可以是非剥夺的。

问题：

1. 长作业有可能一直得不到执行。
2. 不知道作业的执行时间。

### 5.3.3 优先级调度

$SJF$是通用**优先级调度**算法的特例。

对于低优先级的进程，随着时间的进行，逐渐提高该进程的优先级，这是**时效**性。

对于开始的优先级安排，可以考虑：

1. 执行时间
2. 内存占用
3. 文件大小等

### 5.3.4 轮转调度($RR$)

轮转($Round-Robin$,$RR$)调度算法是专门为分时系统设计的。

RR算法是剥夺性的。将一个较小时间单元定义为**时间量**(time quantum)。时间片大小为$10~100ms$。使得$80$%的CPU脉冲都能在一个时间片内做完。

### 5.3.5 多级队列调度

进程分为**前台进程(foreground process)**和**后台进程(background process)**。与后台进程相比，前台进程可能需要更高的优先级。

通常进程进入系统时被永久地分配到某个队列。

设置优点是调度开销低，缺点是不够灵活。

### 5.3.6 多级反馈队列调度

**多级反馈队列(multilevel feedback queue)**调度算法允许进程在队列之间迁移。

## 5.4 多处理器调度

如果有多个CPU，则**负载分配(load sharing)**。

我们主要关注同构系统，这类系统的处理器从功能上来说相同。

### 5.4.1 多处理器调度方法

**非对称多处理(Asymmetric multiprocessing, AMP)**，让一个处理器处理所有调度决定、I/O处理以及其他系统活动，其他处理器只执行用户代码。

**对称多处理(Symmetric Multiprocessing, SMP)**每个处理器自我调度。所有进程可能处于一个共同的就绪队列，或每个处理器都有它自己的私有就绪进程队列。

### 5.4.2 处理器亲和性

**处理器耦合性(pricessor affinity)**，避免将进程从一个处理器移到另一个处理器，而是试图让一个进程运行在同一个处理器上。

### 5.4.3 负载平衡

**负载平衡(load balance)**设法将负载平均分配到SMP系统的所有处理器。

## 5.5 线程调度

区分内核级(kernel-level)线程 和 用户级(user-level)线程。

内核级线程由操作系统调度。用户级线程由线程库调度。

用户级线程为了能够在$CPU$运行，必须部署在内核级线程上。

### 5.5.1 竞争范围

为了实现多对一和多对多模型，以便在$LWP$上运行。这种方案称为进程竞争范围(PCS)。

为了决定哪个内核级线程调度到一个处理器上，内核采用系统竞争范围(SCS)。

### 5.5.2 Pthreads例子



## 5.6 操作系统例子

### $Solaris$ 调度

优先级：实时>系统>分时>

# 第六章 同步

**协作进程(cooperating process)**能与系统内的其他执行进程互相影响。

## 6.1 背景

同时进行count++;和count–;容易产生错误。

## 6.2 临界区问题

每个进程都有一段代码，称为**临界区(critical section)**，进程在该区时可能修改公共变量、更新一个表、写一个文件等。

进入临界区之前，程序需要请求，实现请求代码称为**进入区(entry section)**。临界区之后可以有**退出区(exit section)**，其余代码称为**剩余区(remainder section)**。

![image-20240401144256413](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240401144256413.png)

满足以下三条要求：

1. **互斥(mutual exclusion)**：如果进程$P_i$在其临界区内执行，那么其他进程都不能在其相应的临界区内执行。
2. **空闲让进(progress)**：如果没有进程在其临界区内执行，并且有进程需要进入临界区，那么只有那些不在剩余区内执行的进程可以参加选择，以便确定谁能下次进入临界区，而且这种选择不能无限推迟。
3. **有限等待(bounded waiting)**：从一个进程做出进入临界区的请求直到这个请求允许为止，其他进程允许进入其临界区的次数具有上限。

**易错判断**：

同一时刻，只能有一个进程进入它自己的临界区，其他的进程不能进入其相应的临界区访问相同的共享数据。

## 6.3 Peterson解决方案

![image-20240407143155992](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240407143155992.png)



三个条件都满足

## 6.4 硬件同步

**test_and_set()函数**

![image-20240407143219021](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240407143219021.png)

图6-3：在探索是否锁上的同时，将锁锁上。

图6-4：



**test_and_set()有限等待函数**

![image-20240407150935993](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240407150935993.png)

**compare_and_swap()函数**

![image-20240407151109580](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240407151109580.png)

## 6.5 信号量(semaphore)

![image-20240407151615904](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240407151615904.png)

wait()称为P()操作

signal()称为V()操作

### 6.5.1 信号量的使用

区分计数信号量和二进制信号量。

二进制信号量(binary semaphore)称为互斥锁。

计数信号量

#### 盲目等待

wait(S)和signal(S)函数是原子动作，不可被中断。

```c
wait(S){
	while(S.value<=0);//loop
		S.value– –;
}
signal(S){
	S.value++;
}
```



#### 盲目等待的解决方法

旋转锁;

```c
wait(S){

S.value– –;
	if(S.value<0){
		add this process to S.L;
        block();
    }
}
```

```c
signal(S){
    S.value++;
    if(S.value<=0){
        remove a process P from S.L;//唤醒队列里面的一个等待进程，从阻塞状态转为就绪状态
        wakeup(P);
    }
}
```

如果S.value值为-5，表明队列里面有5个进程在等待。



对于单处理机来说，不建议用盲等。

而多处理机可以使用盲等。

为了保证数据安全，将count的计数改变变成串行操作，即不允许在临界区里面出现block()函数。但是临界区可以中断。

阻塞方法需要上下文切换，而死等的方法不需要上下文切换。



#### 实现原子操作方法

在$wait()$和$sigal()$执行的时候，关中断。

因此，在单处理机上实行关中断的操作是可以的。而多处理机中，当一个处理机关中断时，需要协调其他处理机跟它一同关中断。

## 6.6 经典问题

### 6.6.1 有界缓冲问题

初始化：empty = n, full = 0, mutex = 1

![image-20240407153155188](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240407153155188.png)

mutex表示有空位并且准备往空位里面堆商品

如果wait(empty)和wait(mutex)互换，那么可能将导致死锁。原因是empty为0。

### 6.6.2 读者-写者问题

mutex = 1, rw_mutex = 1, read_count = 0;

第一种解决方案：可能**导致作者饥饿**.

![image-20240408142552748](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240408142552748.png)

读者的临界区是read_count++;和read_count– –;

### 6.6.3 阅览室问题



### 6.6.4 哲学家问题

5个哲学家，5个筷子吃饭

由此提出**管程**的概念

semaphore chopstick[5] (初始化为1)

1. 只能有4个哲学家。
2. 如果两边有两个筷子，那么可以拿，否则就放下。
3. 奇数的哲学家拿左边的筷子，偶数的哲学家拿右边的筷子。



关中断是一种解决方法，但是效率极低。可以用于内核代码。

## 6.7 管程

```C
int count = 0;
int max = 10;
bool is_entry = true
semaphore mutex(1), customer(0), car(0)
car(){
	while(true){
        P(customer)
		P(mutex);
        if(is_empty && count < max){
            count++;
        }
        if(count == max){
            is_entry = false;//不让进
        }
        V(mutex);
        
        V(car)//释放观光车
	}
}
customer(){
    while(true){
        P(mutex);
        if(is_entry){
            V(customer);//提醒car进入
            V(mutex);//释放临界区
            P(car)
            ...//观光
            P(mutex);
            count--;//离开
            if(count == 0){
                is_entry = true;//判断是否是最后一个离开的，如果是，那么就开放缆车
            }
            V(mutex)
        }
        else
            V(mutex);//满员或者人还没走完，直接离开
        
    }
}
```

管程：由程序员提前写好。每个共享变量对应一个相应的管程。

注意：在管程内部任何时刻，可以有多个进程，但是只有一个进程/线程处于活跃状态，只有这样才能保证对共享变量的操作是串行的。

管程中的x.signal()是唤醒操作。

当P进程唤醒进程Q时会发生

1. P睡眠，Q执行
2. P把进程Z继续唤醒，然后Z占用资源，导致Q饥饿
3. P将Q唤醒之后立即退出管程，让Q进行执行

# 第七章 死锁

## 7.2 死锁条件

**必要条件**

1. 存在互斥(mutual exclusion)
2. 保持等待(hold and wait)
3. 非剥夺性(no preemption)
4. 循环等待(circular wait)

## 7.3 死锁处理

1. 预防和避免

   预防不发生，避免可以发生

2. 检测与处理

   允许发生，对其进行处理

3. 忽略

   什么都不做

## 7.4 死锁预防

### 7.4.1 互斥

需要满足互斥要求

### 7.4.2 持有且等待

即手上拥有资源时，不能去申请其他资源。

当进程需求其他资源时候，它必须释放已经持有的所有资源。

缺点：

1. 资源利用率低
2. 可能造成饥饿

### 7.4.3 无抢占

等待资源的进程所持有的资源可以被抢占。被抢占的资源添加到进程等待的资源列表上。只有当进程获得其原有资源和申请的资源时，它才可以重新执行。

### 7.4.4 循环等待

协议：对所有资源类型进行完全排序，而且要求每个进程按递增顺序来申请资源。

方法：每个进程只能按递增顺序申请资源。

## 7.5 死锁避免

死锁预防有很大缺点：设备使用率低，系统吞吐率低。

避免方法是针对每次申请要求，系统在做决定时考虑现有可用资源，现已分配给每个进程的资源和每个进程将来申请与释放的资源。

### 7.5.1 资源分配图算法

![image-20240422145553121](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240422145553121.png)

当请求边变成分配边的时候，如果有环出现，那么这个分配请求不允许被批准。因为一旦批准，就有可能产生死锁。

上图$R_2$不饿能被分配给$P_2$

虚线代表需求边。

### 7.5.2 银行家算法

进程需要声明可能需要的每种类型资源实例的**做大数量**。这个数量不能超过系统资源的总和。

![image-20240422150024898](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240422150024898.png)

#### 7.5.2.1 安全状态

如果存在一个安全序列，使得每个进程都能顺利的获取它们需要的资源。那么该系统就处于安全状态。

当一个进程需求一个空闲资源时，系统必须判断立即分配资源是否会导致系统失去安全状态。

避免算法就是 使得系统始终处于安全状态。

## 7.6 死锁检测







# 第八章 内存管理 

## 8.1 背景

内存是一系列现代计算机操作的中心

CPU操作的数据来自内存，归于内存

### 内存地址

内存有一系列字和字节组成，每一个都有自己的地址

忽略程序如何存储在内存，只关心内存地址序列

### 地址保护

操作系统内核和用户进程要隔离

不同用户之间要隔离

首先需要确保每个进程分离内存空间

1. 需要规定合法的地址空间大小
2. 确保进程只能访问合法空间(软硬件结合方法)

实现上述操作：

1. 一个基址寄存器，一个限长寄存器(限制地址长度范围)。

### 地址绑定(bind)

![image-20240426150923794](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240426150923794.png)

指令和数据到内存地址的绑定发生在三个阶段

1. 编译时：如果在编译时就已知道进程将在内存中的驻留地址，那么就可以生成绝对代码(absolute code)。
2. 加载时：如果在编译时并不知道进程将驻留在何处，那么编译器就应该生成可重定位代码(relocatable code)。
3. 执行时：如果进程在执行时可以从一个内存段移到另一个内存段，那么绑定应延迟到执行时进行。

**逻辑地址**：由CPU产生，与虚拟地址相关。

**物理地址**：与物理内存单元直接相关的地址，直接装入到寻址寄存器中的地址。

1. 在编译时间和加载时间，逻辑地址和物理地址一样。
2. 在执行时，逻辑地址和物理地址不同。

**内存管理单元(MMU)**

是一种硬件，在执行时将虚拟地址和物理地址一一映射。

在简单的MMU中，

## 8.2 交换(swapping)

进程必须在内存中以便执行。进程可以暂时从内存**交换(swap)**到**备份存储(backing store)**，当在此执行时再调回到内存中。

![image-20240429141657353](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240429141657353.png)

### 交换时间

上下文切换时间

RR算法切换时间

**如果没有寻址时间**，大量的交换时间是转换时间。

## 内存管理方式

### 8.3 连续内存分配

需要以高效的方式分配内存空间。主存必须管理。

主存分配两个部分：一个用于驻留操作系统，一个用于用户进程。操作系统可以放在低内存和高内存。

#### 8.3.1 内存保护

防止进程访问不属于它的内存。

要有**重定位寄存器(含有最小的物理地址值)**和**限界寄存器(含有逻辑地址的范围，每个逻辑地址应在限界寄存器规定的范围内)**。

![image-20240429143653892](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240429143653892.png)

保护用户进程防止遭到其他用户进程和操作系统的代码和数据所影响。

#### 8.3.2 内存分配

**固定分区**。每个分区只包含一个进程。多道程序的程度受限于分区数。

优缺点

1. 易于实现。
2. 内碎片过多，进程数固定，分配内存必须大于进程内存。

**可变分区**。操作系统有一个表，记录哪些内存可用和哪些内存已用。所有内存都可用于用户进程，可以作为一大块可用内存，称为**孔(hole)**。

随着系统进程推进，孔的数目将会变成很多个，而且会越来越小。这些孔有可能会变成外碎片。

外碎片是一个相对的概念。

当进程终止时，将该进程所占内存回收，将孔变得更大，以便减少外碎片产生的可能性。

通过自由分区链(或者带环)的来实现自由分区。分配内存之后，改变**分区大小**和**分区始址**。

**first-fit**：分配进程时，从头开始，找到合适的孔就放。

**best-fit：**分配进程时，遍历所有孔，找到哪一个孔是最适合该进程的。或者，每次分配进程后，将孔的大小进行排序。这个方法可能会产生一个最小孔(2KB)，大概率这个孔是用不上的，于是被浪费掉了。

**worst-fit**：每次分配最大的孔。这种策略适用于每次的进程都是**小进程**。

总结：在分配速度和内存利用率方面，first-fit和best-fit比worst-fit表现的好。

#### 8.3.3 碎片

外碎片

### 8.4 非连续内存分配



### 8.5 分区

将物理内存块分成frame(帧、块)，即将物理内存分成固定的块

将逻辑地址空间分成page(页)，即将逻辑地址空间分成固定的块。

分配操作变为：在m个帧当中找n个帧，将内存框进去，这些帧即可以连续，也可以非连续。

### 8.5.1 基本方法

将逻辑地址转化为物理地址

将逻辑地址分成4个页面，内存分成8个物理帧。页表储存页面对应的物理帧，如果要访问page 3，需要在页表上查询page 3对应的物理帧号。

page number(页号)：

page offset(偏移量)：

page table(页表)：

将整除和取余变成移位操作，降低寻址代价。

主存分块表(Frame table)：有状态号、进程号、页号。



分页是**动态重定位**的一种形式。它的依靠就是页表，就像基址寄存器，页表中的每一条对应一个物理帧。

最大的优点就是没有外碎片。内碎片可能存在。但是不多，平均每个进程有$\frac{1}{2}page\ size$大小的内碎片。

主存分块表暗示哪一块是空闲的以及空间分配给了哪一块。一个主存分块表可以为所有进程共享，同时实现所有的地址变换。但是这个主存分块表的**时间开销很大**。



**页表的硬件实现**：

1. 存储在寄存器当中。但是寄存器非常贵，不可能做的很大。
2. 存储在主存中。页表基址寄存器(PTBR)，这个寄存器指向页表，当进程交换时，加载页表仅仅只需要改变PTBR，减少上下文切换。但是每次访问都需要访问两次主存。速度下降了一半。
3. 联想寄存器(TLB)。相当于cache。TLB可以并行搜素(由硬件实现)。操作系统的内核进程会被固定下来，不可被替换。

### 8.5.3 保护

用一个位定义该页的读写权限。

还有一个位表示有效位和无效位。

### 8.5.4 共享页

分页优点之一是可以共享代码。

如果代码是可重入代码或纯代码，则可以共享。纯代码是不能自我修改的代码。

![image-20240510142243699](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240510142243699.png)



**弊端**

共享最小单位是页，所以就会出现粒度问题。做不到真正的巧合，私有的区域不一定正好符合一个页的大小。

## 8.6 页表结构

### 8.6.1 分层分页

问题：对于32bit操作系统来说。

页大小：4K

页表大小：$\frac{2^{32}}{4k} = 1M$

故需要$4MB$的页表项。

由于页表项过大，内存中找不到连续的区域存放，故将页表再次分页，称为快页表，这个页表仅仅$4k$大小。

### 8.6.2 哈希页表

![image-20240510144435072](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240510144435072.png)

## 8.4 分段

分段(segmentation)就是支持用户视图的内存管理方案。逻辑地址空间是由一组段构成。每个段都有名称和长度。地址制定了段名称和段内偏移。

![image-20240510145640455](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240510145640455.png)

将一个进程分成大小不同的段，分配在内存的各个角落。

这种方式跟可变连续内存分配相近。

# 第九章 虚拟内存

## 9.1 背景

**虚拟内存**将用户逻辑内存与物理内存分开。进程的虚拟地址空间就是进程如何在内存中存放的逻辑视图。

![image-20240510152948411](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240510152948411.png)



## 9.2 请求调页

### 9.2.1 基本概念

缺页中断(page fault trap)

对标记为无效的页面访问会产生缺页错误。

![image-20240511142306018](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240511142306018.png)

重启指令(restart instruction)

1. 发生在任意内存调用中
2. 可能发生计算错误(执行两次)
3. 理论上，每条语句都可能会多次缺页。



跨骑：执行$A = A + B$指令时，可能会发生

解决方案：

1. 执行之前，检查$A$和$B$是否都在内存
2. 将$A +B$存储在内存中，最后再将这块值赋值到$A$

### 9.2.2 请求调页的性能

有效访问时间(effective access time,EAT)

$EAT = (1- p)*(memory\ access\ time) + p*(page \ fault\ time)$

$p$是缺页发生的概率。

大多数时间，$p$接近于$0$.

## 9.3 写时复制(copy-on-write)

允许父进程和子进程最初共享相同的页面来工作。这些共享页面标记为写时复制。

即让子进程创建一个页表项，实现对内存的共享

![image-20240511144313972](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240511144313972.png)

假设子进程需要修改$C$页面包含的堆栈时，立刻复制页面$C$的副本，将其映射到子进程的地址空间。然后，子进程修改复制的页面，而不修改属于父进程的页面。

而$vfork()$不采用写时复制，子进程与父进程完全共享地址空间。

## 9.4 页面置换(page replacement)

当进程访问页面时，如果内存中没有自由帧(free frame)时，调用页面置换算法。

过程

1. 找到所需页面的磁盘位置
2. 找到空闲帧(如果有，使用；如果没有空闲帧，则找到牺牲帧，将牺牲帧的内容写到磁盘，修改对应的页表和帧表)
3. 将所需页面读入空闲帧，修改页表和帧表
4. 从发生缺页错误位置，继续用户进程

这种方式需要两个页面传输(一个调出，一个调入)，加倍了缺页处理时间。

增加修改位(modify bit)或脏位(dirty bit)减少回写开销。

一般来说，期望随着帧数量的增加，缺页错误的数量会降低至最小值。

### 9.4.2 $FIFO$页面置换

![image-20240511152125430](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240511152125430.png)

$15$次缺页中断，$12$次页面置换。

### 9.4.3 最优页面置换(optimal page-replacement algorithm)

![image-20240511152845996](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240511152845996.png)

页面置换时，往后面看，取一个最晚引用的页面为牺牲页。

9次缺页，6次置换。



### 9.3.4 LRU置换算法

![image-20240511153443865](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240511153443865.png)

置换最长时间没有被使用的页面。

12次缺页，9次置换。

如何实现$LRU$算法？

1. 计数器：代价高
2. 堆栈：操作繁琐

### 9.4.5 近似$LRU$页面置换

#### 9.4.5.1 额外引用位算法(硬件支持)

引用位初始化为0

如果页面刚刚被访问，引用位将被置为1，表明这个页面刚刚被访问。

对于页表项，增加8个bit的空间。这个空间用来记录访问前后。

规定每过一段时间，对这8bit空间右移位，将引用位移到最高位。每次移位相当于衰减$\frac{1}{2}$。淘汰这8个bit表示的数字当中最小的那个页表项。

#### 9.4.5.2 第二次机会算法

当需要一个帧的时候，指针向前移动直到找到一个引用位为0的页面。在向前移动时，它会清楚引用位。

最坏情况下，当所有引用位都为1时，第二次机会置换退化为FIFO替换。

#### 9.4.5.3 增强型第二次机会算法

将引用位和修改位作为有序对，改进二次机会算法。

![image-20240513143728233](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240513143728233.png)

### 9.4.6 基于计数的页面置换

为每个页面的引用次数保存一个计数器

**最不经常使用**(Least Frequently Used, LFU)页面置换算法要求置换具有最小计数的页面。应该移位来使得衰减呈指数级。

**最经常使用**(Most Frequently Used, MFU)页面置换算法：具有最小计数的页面可能刚刚被引入并且尚未使用。

### 9.4.7 页面缓冲算法

系统通常保留一个空闲帧缓冲池。当出现缺页错误时，会像以前一样选择一个牺牲帧。

实现：

1. 维护一个修改页面的列表。每当调页设备空闲，选择一个修改页面写到磁盘，重复它的修改位。
2. 保留一个空闲帧池，记住哪些页面在哪些帧内。

## 9.5 帧分配

### 9.5.1 帧的最小数



### 9.5.2 分配算法

#### 两主流分配方案

1. 固定分配(平等分配、等比分配)
2. 优先级分配

### 9.5.3 全局分配与局部分配

全局置换允许一个进程从另一个进程那里选择一个帧，而不管该帧是否已分配给其他进程。

局部置换要求每个进程只从它自己分配的帧中选择。

局部置换优点是可以避免进程之间相互干扰。但是需要为每个进程合理分配物理帧，避免颠簸。

局部置换缺点是一旦资源紧张，没办法解决。

全局置换优点是从其他进程中得到自由空间，同时自己的空间也能被抢夺，以实现全局动态分配。

全局置换缺点是会出现连锁反应，进而可能行程全局颠簸问题。

## 9.6 系统颠簸(system thrashing)

如果一个进程的调页时间多余它的执行时间，那么这个进程就在抖动，即内存和磁盘的空间相互转换。这种高度的页面调度活动称为抖动。

### 9.6.1 颠簸原因

进程太多，导致内存紧张。

颠簸一大特点是缺页率很高。

颠簸会导致CPU利用率大大降低。



如何避免颠簸?

工作集模拟

缺页频率控制方案

### 9.6.2 工作集策略

局部性模型提出，随着进程执行，它从一个局部移向另一个局部。局部性是最近使用页面的一个集合，一个程序通常由多个不同的可能重叠的局部组成。

工作集模型是基于局部性假设的。得到一个进程中最大的物理帧使用数，然后分配时就分配这个最大数量。

### 9.6.3 缺页错误频率(Page-Fault Frequency, PFF)

工作集控制抖动优点笨拙。故采用PFF算法更为直接。

如果进程缺页率高于上限，那么需要给该进程一些物理帧；如果进程缺页率低于下限，那么该进程可能具有太多的物理帧，需要剥夺一些。

这样实现了物理帧的动态分配。

## 9.7 内存映射文件

采用read(), open(), write()来进行内存映射。





## 9.8 分配内核内存

### 9.8.1 伙伴系统(buddy system)

从物理连续的大小固定的段上进行分配。采用2的幂分配器(power-of-2 allocator)来满足请求分配单元大小为2的幂(4KB、8KB、16KB)。

但是这样分配产生的内碎片较多。

### 9.8.2 slab分配

每个slab由一个或多个物理连续的页面组成。每个cache由一个或多个slab组成。每个内核数据结构都有一个cache。

## 9.9 其他注意事项

### 9.9.1 预调页面

prepaging试图阻止大量的最初调页，一次性的把可能访问的页面读进来，可能会节省很多时间。但是缺点是有可能会产生资源浪费。

![image-20240517143127438](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240517143127438.png)

### 9.9.2 页面大小

考虑本地行、缺页率、也表达小、内碎片、IO开销等问题

趋势是使得页面大小越来越大。从而除了使得内碎片增大以外，其他的趋势都是好的。

### 9.9.3 $TLB$范围

TLB范围= (TLB可以容纳的页表项)×(页表大小)

TLB范围为TLB覆盖的内存范围。

可以增大页面大小或者提供多种页面大小。

### 9.9.5 程序结构

如果定制二维数组int[128, 128]

# 第十章 文件系统

## 10.1 文件概念

操作系统对存储设备的物理属性加以首相，从而定义逻辑存储单位，即文件(file)。文件由操作系统映射到物理设备上。这些存储设备通常是非易失性的，因此在系统重新启动之间内容可以持久。

文件是一个存储在外部存储器的相关信息的集合。

数据文件：二进制

程序文件：源程序

无格式文件：

格式文件：

### 10.1.1 文件属性

名称、标识符(identifier, 文件的句柄)、类型、位置、尺寸、保护、时间、日期、用户标识。

**标识符**是唯一标记(通常为数字)标识文件系统的文件，它是文件的非人类可读的名称。

### 10.1.2 文件操作

文件为抽象数据类型。

1. 创建文件
2. 写文件
3. 读文件
4. 重新定位文件
5. 删除文件
6. 截断文件



对于open(File)：

1. 通过文件名，找到对应的目录，在目录里面，进行文件的匹配，即得到文件对应的磁盘位置。
2. 将文件目录项内容拷贝到系统**打开文件表(the open-file table)**
3. 分配一个文件句柄，当下次想要访问文件的时候，可以通过系统打开文件表直接得到文件所在内存，即将文件目录所在的系统打开文件表位置，复制到进程打开文件表的一个指针(让指针指向该地址)。返回进程打开文件表的内容给进程。

open()和close()很复杂，因为不同的应用可能会在同一时间访问相同的文件。

所以将打开文件表分成两层：

1. 系统打开文件表：所有的打开文件目录项放在此处。
2. 进程打开文件表：打开文件名，指针指向系统文件表。可以根据指针得到目录项，然后再根据目录项得到所在的文件。

打开文件有如下关联信息：

1. 文件指针
2. 文件打开计数
3. 文件的磁盘位置
4. 访问权限

文件锁(file lock)允许一个进程锁定文件。

共享锁(shared lock)类似于读者锁，以便多个进程可以并发获取它。独占锁(exclusive lock)类似于写者锁；一次只有一个进程可以获取这样的锁。

### 10.1.3 文件类型

![image-20240520141346673](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240520141346673.png)

### 10.1.4 文件结构

文本文件和二进制文件

最小数量的文件结构

### 10.1.5 内部文件结构

逻辑记录大小、物理块大小和打包计数确定了每个物理块可有多少逻辑记录。打包可以通过用户应用程序或操作系统来完成。

所有文件系统都有内部碎片；块越大，内部碎片也越大。

## 10.2 访问方法

### 10.2.1 顺序访问

文件信息按顺序(即一个记录接着一个记录地)加以处理。

读操作，读取文件的下一部分，并且自动前移文件指针以便跟踪I/O位置。写操作对文件的结尾书写内容，并前移到新写材料的末尾(文件的新结尾)。

顺序访问是基于文件的磁带模型；它不但适用于顺序访问设备，也适用于随机访问设备。

![image-20240520143415616](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240520143415616.png)

### 10.2.2 直接访问

另一种方法是**直接访问(direct access)**或**相对访问(relative access)**。这里文件由固定长度的**逻辑记录(logical records)**组成，以允许程序按任意顺序进行快速读取和写入记录。

![image-20240520143857722](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240520143857722.png)

### 10.2.3 其他访问方法

创建文件**索引(index)**。首先搜素索引表，找到文件索引，然后根据指针直接访问文件并且找到所需记录。

对于大文件，索引文件本身可能变得太大而无法保存在内存中。一种方法是为索引表创建索引：主索引文件包含指针，以指向辅助索引文件，而辅助索引文件包括指针，以指向实际的数据项。

IBM的索引顺序访问方法(Indexed Sequential-Access Methon, ISAM)采用小主索引。

## 10.3 目录于磁盘的结构

一个存储设备可以按整体来用于文件系统。存储设备可以组成RAID集

分区可用于限制单个文件系统的带线啊哦，将多个类型的文件洗头工放在同一个设备上，或留下设备的一部分以为他用。

### 10.3.1 存储结构

![image-20240520150844388](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240520150844388.png)

### 10.3.2 目录概述

1. 搜素文件
2. 创建文件
3. 删除文件
4. 重命名
5. 遍历文件系统

目录创建原则：

1. 效率：需要提高文件应用效率
2. 命名：不可有相同的名字

### 10.3.3 单级目录

所有文件都包含在同一目录中。

### 10.3.4 两级目录

每个用户都有自己的用户文件目录(User Fle Directory, UFD)。当用户作业开始或用户登录时，搜索系统的主文件目录(Master File Directory, MFD)。

### 10.3.5 树形目录

树是最常见的目录结构，有一个根目录，系统内的每个文件都有唯一的路径名。

![image-20240520152139059](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240520152139059.png)

目录包括一组文件或子目录。目录不过是一个文件，但是按特殊方式处理。每个目录条目都有一位来将目录定义为文件(0)或子目录(1)。

当前目录(current directory)包括进程当前感兴趣的大多数文件。

绝对路径名(absolute path name)从根开始，遵循一个路径到指定文件，并给出路径上的目录名。相对路径名(relative path name) 从当前目录开始，定义一个路径。

### 10.3.6 无环图目录

公共子目录共享，一个共享的目录或文件可同时位于文件系统的两个或多个地方。

无环图(acyclic graph)允许目录共享子目录和文件。

![image-20240520152915774](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240520152915774.png)

目录结构的主流。

**链接(link)**实际上是另一文件或子目录的指针。

## 10.4 文件系统安装

文件系统在用于系统的进程之前必须先安装(mount)。

操作系统需要知道设备的名称和安装点(mount point)。有的操作系统要求提供文件系统类型；其他检查设备结构并确定文件系统的类型。

## 10.5 文件共享

### 10.5.1 多用户

为了实现文件的高效利用，避免过多的数据。

必须采用单一版本的数据共享来保证数据重用性。

### 10.5.2 远程文件系统

实现方法：

1. 通过ftp程序在机器之间手动传送文件。
2. 通过**分布式文件系统(Distributed File System, DFS)**，远程目录从本机上可直接访问。
3. 万维网(World Wide Web, WWW)，在某些方面回到了第一种。

#### 10.5.2.1 客户机-服务器模型

远程文件系统允许一台计算机安装一台或多台远程机器上的一个或多个文件系统。包含文件的机器是服务器，需要访问文件的机器是客户机。

#### 10.5.2.2 分布式信息系统

为了更易管理客户机-服务器系统，**分布式信息系统(distributed information system)**也称为分布式**命名服务(distributed naming service)**，对远程计算所需信息提供统一访问。

### 10.5.3 一致性语义(consistency semantic)

这是一个重要准则，用于评估支持文件共享的文件系统。

## 10.6 保护

、



# 第十一章 文件系统实现

## 11.1 文件系统结构

文件系统(file system)提供高效和便捷的磁盘访问，以便允许轻松存储、定位、提取数据。文件系统有两个截然不同的设计问题。第一个问题是，如何定义文件系统的用户接口。这个任务涉及定义文件及其属性、所允许的文件操作、组织文件的目录结构。第二个问题是，创建算法和数据结构，以便映射逻辑文件系统到物理外存设备。

I/O控制(I/O control)层包括设备驱动程序和中断处理程序，以在主内存和磁盘系统之间传输信息。设备驱动程序可以作为翻译器。它的输人为高级命令，如“检索块123”。它的输出由底层的、硬件特定的指令组成，硬件控制器利用这些指令来使IO设备与系统其他部分相连。设备驱动程序通常在 O控制器的特定位置写入特定位格式，告诉控制器对设备的什么位置采取什么动作。

基本文件系统(basic file system)只需向适当设备驱动程序发送通用命令，以读取和写人磁盘的物理块。每个物理块由磁盘的数字地址来标识(例如，驱动器(device)1、柱面(cylinder)73、磁道(track)3、扇区(sector)10)。该层也管理内存缓冲区和保存各种文件系统、目录和数据块的缓存。在进行磁盘块传输之前，分配一块缓冲区。当缓冲区已满时缓冲管理器必须找到更多缓冲内存或释放缓冲空间，以便允许完成IO请求。缓存用于保存常用的文件系统元数据，以提高性能;因此管理它们的内容对于系统性能优化至关重要。

文件组织模块(file-organization module)知道文件及其逻辑块以及物理块。由于知道所用的文件分配类型和文件位置，文件组织模块可以将逻辑块地址转成物理块地址，以供基本文件系统传输。每个文件的逻辑块从0(或1)到N编号;而包含数据的物理块并不与逻辑号匹配，因此需要通过转换来定位块。文件组织模块还包括可用空间管理器，以跟踪未分配的块并根据要求提供给文件组织模块。

最后，逻辑文件系统(logical file system)管理元数据信息。元数据包括文件系统的所有结构，而不包括实际数据(或文件内容)。逻辑文件系统管理目录结构，以便根据给定文件名称为文件组织模块提供所需信息。它通过文件控制块来维护文件结构。文件控制块(File Control Block，FCB)包含有关文件的信息，包括所有者、权限、文件内容的位置等逻辑文件系统也负责保护，



## 11.3 目录实现

### 11.3.1 线性列表

采用文件名称和数据块指针的线性列表。这种方法编程简单，但执行费时。

### 11.3.2 哈希表

除了采用线性列表存储目录条目外，还采用哈希数据结构。哈希表根据文件名称获得一个值，并返回线性列表内的一个元素指针。大大减少目录搜索时间，插入和删除直截了当。

## 11.4 分配方法

磁盘直接访问的特点在文件实现时提供了灵活性。很多文件都是存储在同一磁盘上的。

磁盘空间分配方法：连续(Contiguous)、链接(Link)、索引(Indexed)

### 11.4.1 连续分配

要求每个文件在磁盘上占有一组连续的块。但是不知道文件占用多大，所以总是有预留，或者预留空间不够。

问题：外碎片问题严重，空间浪费过多。文件不能随意增长，即长度被限制，想要增长只能用指针指向其他的连续空间，但是如果这样做，速度明显会降低。

### 11.4.2 链接分配

物理块一个一个用指针链接起来，只记录其实物理块和结束物理块。

只能有效用于顺序访问，不能有效支持文件的直接访问。

可靠性低，指针空间浪费。

连接分配的重要变种是文件分配表(File-Allocation Table, FAT)。在该表中，每个磁盘块都有一个条目，并可按块号来索引。通过该表，可以支持直接访问。

![image-20240527145700507](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240527145700507.png)

### 11.4.3 索引分配

索引分配通过将所有指针放在一起，即索引块(index block)，解决了直接访问问题。

每个文件都有索引块，是一个磁盘块地址的数组。目录包含索引块的地址。

![image-20240527150241614](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240527150241614.png)

## 11.5 空闲空间管理

### 11.5.1 位向量

物理块空闲则置为1

空间浪费较大。

### 11.5.2 链表

将空闲物理块链接起来。

效率较慢

### 11.5.3 组

是索引的变形。

在第一个空闲块中存储n个空闲块的地址。这些快的前n-1个为空，最后一块包含另外n个空闲块的地址，如此继续。

### 11.5.4 计数



## 11.6 效率和性能

### 11.6.1 效率

1. 预分配。
2. 改变扇区(cluster)大小，减少内碎片。

### 11.6.2 性能

1. 最后被访问，这一数据信息，即访问一次，就要读写一次数据。如果对于不重要的文件去掉这一功能，可以节省很多IO时间。
2. 指针大小，可以缩小指针大小。

但是如果不是随时随地写磁盘，一旦出了故障，那么成果未被保存，将会前功尽弃。所以我们定时5分钟自动保存，即同步写磁盘。数据库一旦出现故障， 要么重做要么回滚。所以一般数据都是异步写磁盘，但是对于重要信息，我们进行同步写磁盘。

# 第十二章 大容量存储结构

## 12.1 概述

文件系统由三部分组成

物理结构：

性能特点：

操作系统服务：

## 12.2 磁盘结构

**逻辑块(logical blocks)：**是一个一维的数组，这个一维数组映射到磁盘的扇区上面。但是由于磁盘容易损坏，这个映射关系可能会非常复杂。









# 操作系统复习

操作系统概念

## 操作系统共性

多道、分时多任务

## 现代操作系统特征

并发、共享、虚拟

## 用户模式和内核模式

对系统安全性有危害的各种操作，操作系统把它准备好打包成系统调用。对这些重要资源的修改，需要进行系统调用。

若想要调用系统调用，需要进入内核模式。

## 进程和程序的区别

程序是被动实体，一段代码

进程是主动实体，是执行文件进入内存之后，指令流在流转。









## 公共服务



## UI界面

用户界面

系统调用、API(应用程序接口)是程序员调用的。API函数可以实现对用户的统一标准。





































