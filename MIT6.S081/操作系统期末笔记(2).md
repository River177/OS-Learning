# 操作系统期末笔记

# 第八章

![image-20240616194226322](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240616194226322.png)

指令和数据到内存地址的绑定发生在三个阶段

1. 编译时：如果在编译时就已知道进程将在内存中的驻留地址，那么就可以生成绝对代码(absolute code)。
2. 加载时：如果在编译时并不知道进程将驻留在何处，那么编译器就应该生成可重定位代码(relocatable code)。
3. 执行时：如果进程在执行时可以从一个内存段移到另一个内存段，那么绑定应延迟到执行时进行。

## 逻辑地址和物理地址

**物理地址：**与物理内存单元直接相关联的地址，直接装入到寻址寄存器中的地址。

**逻辑地址：**由CPU生成，也成为虚拟地址

MMU(内存管理单元)：在运行时将虚拟地址映射到物理地址的硬件设备

## 连续内存分配

需要以高效的方式分配内存空间。主存必须管理。

主存分配两个部分：一个用于驻留操作系统，一个用于用户进程。操作系统可以放在低内存和高内存。

关于**内存保护**：

防止进程访问不属于它的内存。

要有**重定位寄存器(含有最小的物理地址值)**和**限界寄存器(含有逻辑地址的范围，每个逻辑地址应在限界寄存器规定的范围内)**。

保护用户进程防止遭到其他用户进程和操作系统的代码和数据所影响。



对于**连续内存分配**，每个进程都包含在一个单独的连续内存段中

**固定分区**。在系统生成时将内存划分为几个固定大小的分区 要么是大小相等的分区，要么是大小不等的分区

每个分区只包含一个进程。多道程序的程度受限于分区数。当分区空闲时，从输入队列中选择一个进程并将其加载到空闲分区中。

优点：实现简单、开销小

缺点：有内碎片，分配的内存可能大于请求的内存，进程数量固定

**可变分区。**分区是动态创建的 每个进程都可以加载到与该进程大小完全相同的分区中。。

操作系统有一个表，记录哪些内存可用和哪些内存已用。所有内存都可用于用户进程，可以作为一大块可用内存，称为**孔(hole)**。

随着系统进程推进，孔的数目将会变成很多个，而且会越来越小。这些孔有可能会变成外碎片。

外碎片是一个相对的概念。

当进程终止时，将该进程所占内存回收，将孔变得更大，以便减少外碎片产生的可能性。

通过自由分区链(或者带环)的来实现自由分区。分配内存之后，改变**分区大小**和**分区始址**。

**first-fit**：分配进程时，从头开始，找到合适的孔就放。

**best-fit：**分配进程时，遍历所有孔，找到哪一个孔是最适合该进程的。或者，每次分配进程后，将孔的大小进行排序。这个方法可能会产生一个最小孔(2KB)，大概率这个孔是用不上的，于是被浪费掉了。

**worst-fit**：每次分配最大的孔。这种策略适用于每次的进程都是**小进程**。

**外碎片：**当进程从内存中加载和移除时，空闲的内存空间被分割成大量的小洞。有足够的总内存空间来满足请求，但它不是连续的。

**内碎片：**分配的内存可能略大于请求的内存 一个18464字节的漏洞 进程请求18400字节 剩下64字节的漏洞，管理这个漏洞的开销将大于漏洞本身 64字节将被分配给进程

减少碎片方法：

Compaction(紧凑)：动态重定位来移动进程和内存，但是代价高昂、

Paging(分页) and segmentation(分段)：处理外碎片

关于**分页：**

**frame(帧，块)** 将物理内存划分为固定大小的块

**page(页)** 将逻辑内存划分为固定大小的块，页面大小等于帧大小 查找n个空闲帧来加载大小为n个页面的程序

**逻辑地址意义：**由CPU生成的每个地址分成两部分：页码(Page number)、和页偏移(Page offset)。页码作为页表的索引。页表包含每页所在物理内存的基地址。这个基地址和页偏移的组合就形成了物理地址，可以发送到物理单元。

![image-20240615102510045](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240615102510045.png)

如果逻辑地址空间为$2^m$，页表大小为$2^n$，那么页码为高$m-n$位，而低$n$位表示页偏移。

![image-20240615102914663](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240615102914663.png)

分页是一个动态重定位形式：每个逻辑地址都由分页硬件绑定到某个物理地址 使用分页类似于使用基本(或重定位)寄存器表，每个内存帧对应一个寄存器

分页无外部碎片，期望内部碎片为每个进程一个半页，所以要减小页面大小。

虽然内碎片让页面减小，但是页面大小增大可以使得页表大小减少，以及磁盘I/O的效率增大。故一般来说，随着进程、数据和主内存变大，页面大小也会随着时间的推移而增长。

**主存分块表(Frame table)：**每个物理页帧都有一个表项指示帧表示帧是否空闲或分配给了哪个进程。

TLB(联想寄存器)：一种特殊的快速查找硬件缓存，称为翻译暂存缓冲区(TLB)或关联内存 TLB仅包含少量页表项 TLB -并行搜索

![image-20240615104304697](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240615104304697.png)

由于页表过大，所以解决页表过大问题

分级页表：如图，10位的外页表页码，中间10位是外页表的页偏移，最后12位是内页表的页偏移。

![image-20240615104938057](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240615104938057.png)

**倒置页表：**

每个表项由<process-id, page-number>组成 

process-id:地址空间标识符 

page-number:页面的虚拟地址 

![image-20240615110328476](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240615110328476.png)

# 第九章 虚拟内存

**需求调页(Demand paging)：**只在需要时才将页面放入内存中 类似于分页系统的交换。将进程视为一系列页面查看，只将那些必要的页面放入内存，而不是交换整个进程。

页表项有一个 valid-invalid 位，v表示页面合法且在内存中，i表示页面不合法或不在内存。

辅助内存保存内存中不存在的页面

页面错误：访问被标记为无效的页面会导致页面错误陷阱(缺页中断)，这个陷阱是将所需的页面带入内存

PCB(进程控制块)：进程号，进程控制器，内存管理信息。

**发生缺页错误时：**

1. 查看PCB确定是否是无效引用，如果不是，那么需求页面是不在内存中的。
2. 获取空帧
3. 将所需页面放入空帧
4. 修改页表，将验证位置为v
5. 重新启动导致页面故障的指令

**页面置换：**

当进程访问页面时，如果内存中没有自由帧(free frame)时，调用页面置换算法。

过程

1. 找到所需页面的磁盘位置
2. 找到空闲帧(如果有，使用；如果没有空闲帧，则找到牺牲帧，将牺牲帧的内容写到磁盘，修改对应的页表和帧表)
3. 将所需页面读入空闲帧，修改页表和帧表
4. 从发生缺页错误位置，继续用户进程

这种方式需要两个页面传输(一个调出，一个调入)，加倍了缺页处理时间。

增加**修改位(modify bit)**或**脏位(dirty bit)**减少回写开销。

一般来说，期望随着帧数量的增加，缺页错误的数量会降低至最小值。

**脏位：**通过页面替换，页面故障服务时间增加了一倍。(一页进，一页出)。如果修改，页出和页入；如果干净，只是页入。

目标：

为了实现带有页面替换的需求分页，需要两种算法 1框架分配算法 决定给每个进程分配多少帧 2页面替换算法 决定选择和替换哪些页面

下图是**页面置换流程：**

![image-20240615130551478](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240615130551478.png)

## 页面置换算法

1. **FIFO页面置换**：可能会导致Belady异常(更多的帧导致更多的页面错误发生)
2. **最优(OPT, Optimal)页面置换算法**：更换最长时间不用的页面。 更低的页面错误率，没有白兰地异常，难实现，可用于对比其他算法。
3. **LRU(Least Recently Used)算法**：替换那些最长时间未被使用的页面。

如何实现LRU？

计数器 数字在每次内存引用都增加，替换那些数字大的。

堆栈 每当一个页面被引用时，将其替换到顶部。每次替换都替换栈底部的页面，即LRU页面。

**4. LRU Approximation(近似)算法**：设置一个引用位(Reference bit)，初始值是0。每次页面被引用时，将该位置为1。

1. 附加参考位算法：页表中预留8位字节。每次根据定时器右移引用位。解释为无符号整数，编号最低的为LRU页面，可被置换。![image-20240615131819797](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240615131819797.png)
2. 第二次机会(Clock)：检查引用位时，如果为0，则置换该页面。如果为1，则将其置为0，将其留在页面。
3. 增强的二次机会算法：![image-20240615132154037](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240615132154037.png)

5. 基于计数器的页面置换
6. 页面缓冲算法：系统维护一个空闲帧池，页面发生时，读取所需页面到空闲帧，受害帧稍后换出。

**帧分配**

固定分配：1平等，2按比例分配

优先级分配

全局置换允许一个进程从另一个进程那里选择一个帧，而不管该帧是否已分配给其他进程。

局部置换要求每个进程只从它自己分配的帧中选择。

局部置换优点是可以避免进程之间相互干扰。但是需要为每个进程合理分配物理帧，避免颠簸。

局部置换缺点是一旦资源紧张，没办法解决。

全局置换优点是从其他进程中得到自由空间，同时自己的空间也能被抢夺，以实现全局动态分配。

全局置换缺点是会出现连锁反应，进而可能行程全局颠簸问题。

**系统颠簸**

如果一个进程的调页时间多余它的执行时间，那么这个进程就在抖动，即内存和磁盘的空间相互转换。这种高度的页面调度活动称为抖动。

颠簸原因：进程太多，导致内存紧张。颠簸一大特点是缺页率很高。颠簸会导致CPU利用率大大降低。

**局部性模型**指出，当一个流程执行时，它将一个局部性移动到另一个局部性。局部性是一起使用的一组页面。一个程序通常由几个不同的地方组成，这些地方可能重叠。如果一个进程有足够的帧来包含它的位置，那么它就能顺利运行。

**工作集**是最近的页面引用中的页面集。如果页面处于活动使用状态，它将位于工作集中。如果它在上次引用后不再被使用时间单位，它将从工作集中删除。

**页面大小选择**必须考虑: 内部碎片 页面表大小 I/O开销(寻道时间、延迟时间、传输时间) 局域性 页面错误率

TLB长度= (TLB大小)X(页大小)

# 第十章 文件系统接口

**文件属性：**名称、标识符(identifier, 文件的句柄)、类型、位置、尺寸、保护、时间、日期、用户标识。

**标识符**是唯一标记(通常为数字)标识文件系统的文件，它是文件的非人类可读的名称。

**顺序访问：**

文件信息按顺序(即一个记录接着一个记录地)加以处理。

读操作，读取文件的下一部分，并且自动前移文件指针以便跟踪I/O位置。写操作对文件的结尾书写内容，并前移到新写材料的末尾(文件的新结尾)。

顺序访问是基于文件的磁带模型；它不但适用于顺序访问设备，也适用于随机访问设备。

![image-20240520143415616](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240520143415616.png)

**直接访问：**

另一种方法是**直接访问(direct access)**或**相对访问(relative access)**。这里文件由固定长度的**逻辑记录(logical records)**组成，以允许程序按任意顺序进行快速读取和写入记录。

![image-20240520143857722](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240520143857722.png)

访问控制列表(ACL)：指定每个用户的名称及其允许访问的类型。当用户请求访问特定文件时，操作系统将检查与该文件关联的访问列表。如果该用户属于可访问的，则允许访问。否则会发生保护冲突，并且用户作业拒绝访问该文件。

# 第十一章 文件系统

**FCB：**文件控制块 包含文件内容的归属、权限、位置等信息 负责保护和安全。

文件权限，所有权，大小，数据块的位置

磁盘空间分配方法：连续(Contiguous)、链接(Link)、索引(Indexed)

**连续分配：**

要求每个文件在磁盘上占有一组连续的块。但是不知道文件占用多大，所以总是有预留，或者预留空间不够。

支持顺序访问和直接访问(随机访问)

问题：外碎片问题严重，空间浪费过多。文件不能随意增长，即长度被限制，想要增长只能用指针指向其他的连续空间，但是如果这样做，速度明显会降低。

改进方法：

基于区段的文件系统 最初分配一个连续的空间块 如果空间不够用，则添加一个区段 区段是一个连续的磁盘块 文件由一个或多个区段组成

**链接分配：**

物理块一个一个用指针链接起来，只记录起始物理块和结束物理块。

只能有效用于顺序访问，不能有效支持文件的直接访问。

可靠性低，指针空间浪费。

**改进：**文件分配表(File-allocation table, FAT)。

在该表中，每个磁盘块都有一个条目，并可按块号来索引。通过该表，可以支持直接访问。

![image-20240527145700507](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240527145700507.png)

**索引分配：**

索引分配通过将所有指针放在一起，即索引块(index block)，解决了直接访问问题。

每个文件都有索引块，是一个磁盘块地址的数组。目录包含索引块的地址。

![image-20240527150241614](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240527150241614.png)

对于大文件：

1. 链接方案：多个索引表链接在一起
2. 多级索引：易于分页
3. 组合方案

性能：1是存储利用率 2是数据块访问时间

1连续分配:适用于已知大小的文件 2链接分配:适用于存储利用率 3索引分配:访问时间取决于索引结构、文件大小和块位置

**效率和性能**

效率：1预分配 2改变扇区大小(减少内碎片)

性能：不重要的文件去除访问一次就读写一次数据。减少指针大小。双重缓存。对于重要文件同步写磁盘，其他文件异步写磁盘。

# 第十二章 大磁盘存储结构

文件系统组成逻辑上为

(1)用户和程序员到文件系统的接口 

(2)实现内部数据结构和算法的接口 

(3)文件系统的最底层:二级和三级存储结构

光盘结构：

磁盘盘片(盘片):覆盖着磁性材料旋转以每秒60至200次

(磁道):盘片的表面是逻辑上分为环形轨道

(扇区):每个磁道分为几个扇区

(柱面):是一组在一只手臂位置的磁道

一个读写头:“文件”略高于每盘的每个表面

**磁盘结构：**

逻辑块 是最小的传输单位，通常为512字节----4K ，磁盘驱动器被寻址为逻辑块的大一维数组

逻辑块的一维阵列按顺序映射到磁盘的扇区中

扇区0是最外层圆柱上第一磁道的第一个扇区

地址转换：将逻辑块号转换为旧式磁盘地址，该地址由一个柱面号、该柱面中的磁道(/磁头)号和该磁道中的扇区号组成

在实践中，地址转换是困难的 

(1)大多数磁盘有一些有缺陷的扇区，但是映射通过替换磁盘上其他地方的备用扇区来隐藏这一点

(2)每个磁道的扇区数在某些驱动器上不是恒定的。最外层区域的磁道持有更多的扇区 随着磁头从外部移动到内部，驱动器增加其旋转速度，以保持相同的数据在磁头下移动的速率

**磁盘调度：**

对于磁盘驱动器：注意寻道时间和磁盘带宽

寻道时间：是磁盘将磁头移动到包含所需扇区的圆柱体的时间，旋转延迟是等待磁盘将所需扇区旋转到磁头的额外时间。

磁盘带宽：传输的总字节数除以第一次服务请求和最后一次传输完成之间的总时间

FCFS调度算法：按顺序解决磁盘页面调度

SSTF(Short-Seek-Time-First)：从当前头部位置选择具有最小搜索时间的请求 SSTF调度是SJF调度的一种形式 可能会导致一些请求饥饿 

SCAN： 有时被称为电梯算法。磁盘臂从磁盘的一端开始，并向另一端移动，当它到达每个圆柱体时为请求提供服务 在另一端，磁头的运动反向并继续服务 磁头连续地在磁盘上来回扫描

C-SCAN(循环扫描)提供比SCAN更均匀的等待时间 磁头从磁盘的一端移动到另一端，在它移动的过程中为请求提供服务 但是，当它到达另一端时，它立即返回到磁盘的开头，在返回过程中不为任何请求提供服务

LOOK / C-LOOK 类似于SCAN/C-SCAN Arm只执行每个方向上的最后一个请求，然后立即反转方向，而不首先执行到磁盘的末端。

磁盘管理

为了保存文件，操作系统仍然需要在磁盘上记录自己的数据结构，它分两个步骤 1分区 2逻辑格式化

分区将硬盘划分为一组或多组柱面，操作系统可以将每个分区视为单独的磁盘。

逻辑格式化 创建文件系统 构建文件系统的元数据结构 将空闲空间和已分配空间映射为初始空目录

集群 为了提高效率，大多数文件系统将块分组到集群中 磁盘I/O通过块完成 文件I/O通过集群完成，确保I/O具有更多的顺序访问和更少的随机访问

**RAID结构：**

RAID 独立磁盘冗余阵列 用于提供更高的可靠性和更高的数据传输速率(性能)，而不是出于经济考虑

通过冗余提高可靠性

通过并行性提高性能

1. 镜像 读请求可以发送到任意一个磁盘 两个磁盘可以同时处理不同的读请求，因此单位时间内的读次数可以增加一倍
2. 数据分条 1）位级分条 将每个字节的位拆分到多个磁盘 例如，有4个磁盘组成的阵列 每个字节的第i位和第4+i位写入磁盘i 每个磁盘都参与每次访问 4个磁盘组成的阵列可以视为单个磁盘，其扇区是正常访问速率和大小的4倍。2）扇区级分条 3）块级分条

通过数据分条实现的磁盘系统中的并行性有两个主要目标 通过负载平衡提高多个小访问(即访问的页面)的吞吐量 减少大访问的响应时间

**镜像**可靠性高，但成本高 **数据分条**可以提高数据传输速率，但不能提高可靠性

![image-20240616111208070](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240616111208070.png)

RAID 0：在块级别具有数据条带化但没有任何冗余的磁盘阵列

RAID 1：镜像

RAID 2：单个位出错可以为内存系统所检测。差错纠正方案可以存储两个或多个额外位，并且当单个位出错时可以重建数据。

RAID 3和4：3是检测奇数位的错误，4是检测奇数块的错误。

RAID 5：防止像4一样的P直接暴毙。避免了潜在的过度使用可能发生一个奇偶校验磁盘的RAID 4

RAID 6：存储额外的冗余信息，防止硬盘多次故障 每4位数据存储2位冗余数据，系统可容忍2块硬盘故障

RAID 0+1：是先并行再镜像，一旦出错，一整条都不能用

RAID 1+0：是先镜像再并行，出错的话可以使用另一个。





RAID 0+1和RAID 1+0用于性能和可靠性都很重要的地方 RAID 5通常是存储大量数据的首选





# 第六章 信号量

多个进程并发访问和操作共享数据的情况。共享数据的最终值取决于哪个进程最后完成。

解决方案就是同步。

**临界区问题：**

n个进程竞争使用一些共享数据(临界资源) 1修改公共变量 2更新表 3写文件

每个进程都有一个代码段，称为临界段，其中访问共享数据

当一个进程在临界区执行时，其他进程不允许在它们的临界区内执行。即没有两个进程可以在它们的临界区内同时执行。

**满足的三个条件：**

1. **互斥：**当已有进程进入临界区时，其他试图进入临界区的进程必须等待。
2. **空闲让进：**当临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。
3. **有限等待：**对于请求访问临界区的进程，应保证能够在有限的时间内进入。
4. **让权等待：**当进程不能进入临界区时，应立即释放处理器，防止进程空等。

操作系统解决临界区问题两个条件：

1. **非抢占式内核：**不允许处于内核模式的进程被抢占。
2. **抢占式内核：**允许处于内核模式的进程被抢占。

抢占式内核有点：更适合实时编程 可能响应更快，因为内核模式进程运行任意长时间的风险更小

**Peterson’s 解决方案：**

![image-20240616151512262](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240616151512262.png)

**硬件同步：**

采用硬件和软件 API 技术，通过加锁来保护临界区。

![image-20240616152347582](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240616152347582.png)

![image-20240616152359891](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240616152359891.png)

**自旋锁：**

即盲等：当一个进程在其临界区时，任何其他试图进入其临界区的进程都必须在进入代码中不断循环

解决方案：wait():进程可以自己阻塞()而不是忙于等待 signal():将阻塞进程从等待状态改为就绪状态

![image-20240616153152059](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240616153152059.png)

wait()和signal()必须原子地执行

### 6.6.1 有界缓冲问题

初始化：empty = n, full = 0, mutex = 1

![image-20240407153155188](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240407153155188.png)

mutex表示有空位并且准备往空位里面堆商品

如果wait(empty)和wait(mutex)互换，那么可能将导致死锁。原因是empty为0。

### 6.6.2 读者-写者问题

mutex = 1, rw_mutex = 1, read_count = 0;

第一种解决方案：可能**导致作者饥饿**.

![image-20240408142552748](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240408142552748.png)

读者的临界区是read_count++;和read_count– –;

### 6.6.3 阅览室问题



### 6.6.4 哲学家问题

5个哲学家，5个筷子吃饭

由此提出**管程**的概念

semaphore chopstick[5] (初始化为1)

1. 只能有4个哲学家。
2. 如果两边有两个筷子，那么可以拿，否则就放下。
3. 奇数的哲学家拿左边的筷子，偶数的哲学家拿右边的筷子。



关中断是一种解决方法，但是效率极低。可以用于内核代码。

# 第七章 死锁

**死锁的四个必要条件：**

如果在一个系统中以下四个条件同时成立，那么就能引起死锁:

1. **存在互斥(mutual exclusion)**：至少有一个资源必须处于非共享模式，即一次只有一个进程可使用。如果另一进程申请该资源，那么申请进程应等到该资源释放为止。
2. **占有并等待(hold and wait)**：一个进程应占有至少一个资源，并等待另一个资源，而该资源为其他进程所占有。
3. **非抢占(no preemption)**:资源不能被抢占，即资源只能被进程在完成任务后自愿释放。
4. **循环等待(circular wait)**:有一组等待进程{$P_0,P_1,P_2,...,P_n$}，$P_0$等待的资源为$P_1$占有，$P_1$等待的资源为$P_2$占有,……,$P_{n-1}$等待的资源为$P_{}n$占有,$P_n$等待的资源为$P_0$占有。

我们强调所有四个条件必须同时成立才会出现死锁。循环等待条件意味着占有并等待条件。这样四个条件并不完全独立。

**资源分配图：**

![image-20240616155949355](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240616155949355.png)

如果资源分配图没有环，那么系统就不处于死锁状态。

如果有环，那么系统可能会也可能不会处于死锁状态。

1. 如果环上的每个类型只有一个实例，那么环上的进程就死锁
2. 如果每个资源类型有多个实例，那么有环并不意味着出现了死锁

三种方法避免死锁：

1. 预防或避免：预防不发生，避免可以发生
2. 检测和恢复：允许发生，对其进行处理
3. 忽略：什么都不做

**死锁预防：**

1. **互斥：**互斥条件必须成立，因为有的资源本身就是非共享的。例如，一个互斥锁不能同时被多个进程所共享。
2. **持有且等待：**

原则：每个进程申请一个资源时，它不能占有其他资源。
1. 每个进程在执行前申请并获得所有资源。
    要求进程申请资源的系统调用在所有其他系统调用之前进行。
2. 进程仅在没有资源时才可申请资源。
    进程在申请更多其他资源之前，它应释放现已分配的所有资源。

**主要缺点**

1. 资源利用率可能比较低
许多资源可能已分配，但是很长时间没有被使用。
2. 可能发生饥饿
一个进程如需要多个常用资源，可能必须永久等待，因为在它所需要的资源中至少有一个已分配给
其他进程。

3. **无抢占：**如果一个进程持有资源并申请一个不能立即分配的资源，那么它现在分配的资源都可被抢占。该进程之后只有获得原有被抢占的资源和申请的新资源时，才可以重新执行。

4. **循环等待：**

协议：对所有资源类型进行完全排序，而且要求每个进程按递增顺序来申请资源。

方法：每个进程只能按递增顺序申请资源。

**死锁避免：**

针对每次申请要求，系统在做决定时考虑现有可用资源，现已分配给每个进程的资源和每个进程将来申请与释放的资源。

每个进程都应声明可能需要的每种类型资源的最大数量。

**安全状态：**如果存在一个安全序列，使得每个进程都能顺利的获取它们需要的资源。那么该系统就处于安全状态。

当一个进程需求一个空闲资源时，系统必须判断立即分配资源是否会导致系统失去安全状态。

避免算法就是 使得系统始终处于安全状态

**死锁避免可以用资源分配图算法来解决**：

假设把相关资源分配给某一申请它的进程，那么调用环检测算法检测是否存在环，如果存在环则该资源此时不能分配给该进程。

因为存在环就代表系统处于不安全状态。

**银行家算法：**

进程需要声明可能需要的每种类型资源实例的**做大数量**。这个数量不能超过系统资源的总和。

![image-20240616162009229](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240616162009229.png)

![image-20240616162228075](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240616162228075.png)

**死锁检测与恢复：**

检测：一种检查系统状态以确定是否发生死锁的算法。

恢复：从死锁中恢复的算法。

两种检测算法：

1. **等待图：**将资源分配图变形为等待图，当等待图中有一个环，系统死锁。

![image-20240616162452379](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240616162452379.png)

2. **银行家算法：**

![image-20240616162614315](C:\Users\hsbxa\AppData\Roaming\Typora\typora-user-images\image-20240616162614315.png)

**死锁恢复：**

1. **进程终止：**若一次终止所有进程代价太大，故一次终止一个进程。需要确定哪个死锁进程应该终止，理论上应该中止造成最小代价的进程，但是最小代价并不精确，可以是进程优先级，进程已计算多久等等。
2. **资源抢占：**不断抢占一些进程的资源以便给其他进程使用，直到死锁循环被打破为止。

1）选择牺牲进程：确定抢占顺序，使代价最小。代价因素包含很多，例如死锁进程拥有的资源数量等等。

2）回滚：将死锁进程回滚到某个安全状态。这需要系统维护有关运行进程的更多状态信息

3）饥饿：防止资源不会总是从同一个进程中被抢占。
